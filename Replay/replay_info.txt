
Replay에 대해서

첫번째 후보. 기록을 할 수 있게 만들어진 .ll 파일안에 reply를 하는 기능 역시 들어가 있다.

개요

Pass를 통해 생성된 .ll 파일에는 기록과 재현을 위한 코드가 둘 다 추가가 된 상태이다.
예를 들어서 명령어 argv 로 -reply 라는 옵션을 준다고 한다면 기록이 아닌 재현이 실행된다.
만약 int x = InputToUser(); 라는 코드가 존재를 했고 -record 라면 유저 입력 값이
할당이 되고 그리고 그 값을 .txt 파일에 저장을 하지만 만약 -reply 라면 유저로부터 입력
을 받는 것이 아닌 그 때 당시 x의 값을 .txt 파일로부터 읽어올 수 있게 구현한다.

진행 과정

1. 사용자가 작성한 foo.c 파일(예시)이 존재를 한다.
2. foo.c 파일을 foo.ll 로 변경을 한다.
3. Pass 를 통해서 foo.ll 파일을 기록/재현 이 가능한 foo.ll로 업데이트 또는 새로운 foo_result.ll 파일을 생성한다.
4. 기록/재현 기능이 추가된 foo.ll 파일을 실행파일 foo로 바꾼다.
5. ./foo 를 실행할 때 -record 옵션을 주어 기록을 한단.
6. 해당 디렉토리 안에 기록 파일(.txt)이 추가가 된다.
7. ./foo 를 한번 더 실행할 때 -reply 옵션을 주어 재현을 한다, 이 때 6번에서 생성된 .txt 기록파일을 통해서 재현을 한다.

의문점

1. 프로그램을 실행한다는 의미 : 메모리를 할당/해제 같은 컴퓨터 자원을 실제로 사용하면서 기능등을 수행?
2. 재현은 프로그램이 실행되는 것이 아니라고 하였다, 하지만 위 과정은 재현을 위해 프로그램 실행을 하는 것 아닌가?

두번째 후보. pass 를 통해 삽입된 기능은 기록만을 위한 기능이다. reply는 다른 프로그램을 만든 후 그 프로그램을 사용해서 구현을 한다.

개요

Pass를 사용해서 만들어진 .ll 파일 안에는 기록(record)를 위한 기능만이 추가가 된 상태이다. 그래서 만들어진 .ll 파일을 실행을
하면 실행될 때 당시에 정보들이 .txt 파일(이후 기록파일이라고 이 문서에서 사용)이 실행 디렉토리 안에 추가가 된다. 그리고 추가된
기록파일과 foo.c 파일을 인자로 받는 또 다른 reply 프로그램을 구현한다.
그리고 그 reply 프로그램이 foo.c 파일을 줄 단위로 읽어 오면서 줄 번호로 기록파일로부터 정보를 가져와서 사용자에게 출력을 해준다.

진행 과정

1. 사용자가 작성한 foo.c 파일(예시)이 존재를 한다.
2. foo.c 파일을 foo.ll 로 변경을 한다.
3. Pass 를 통해서 foo.ll 파일을 기록 이 가능한 foo.ll로 업데이트 또는 새로운 foo_result.ll 파일을 생성한다.
4. 기록/재현 기능이 추가된 foo.ll 파일을 실행파일 foo로 바꾼다.
5. ./foo 를 실행하면 실행이 되고 실행 될 때 정보가 기록파일(.txt)로 실행 디렉토리 안에 추가가 된다.
6. 따로 구현한 reply 프로그램을 사용해서 사용자가 작성한 원본 소스파일(foo.c)와 기록파일(.txt)을 인자로 받아서 foo.c에 대한
    분석 정보를 출력을 한다.

의문점

1. 해당 방법은 재현을 하는 것이 아닌 것 같다.
2. 만약 reply라는 외부 프로그램을 사용하면서 재현이라는 기능을 만족시키려면 reply 라는 프로그램의 소스코드 수준에서 구문 분석을
해야 한다. 예를 들어서 현재 reply_test 프로그램에서 인자로 받은 foo.c 파일을 줄 단위로 읽어 올 때 읽어온 한 줄을 구문 분석을
해서
